<!DOCTYPE html>
<html>

<head>
  <title>Screen capturing tools</title>
</head>

<body>
  <table>
    <tr>
      <td>
        <canvas id='canvas' style="background: gray; padding: 10px;"></canvas>
      </td>
    </tr>
    <tr>
      <td>
        <input type="button" id="ssanimation" value="â¹ï¸ Stop"><br><!--â–¶ï¸ Start-->
        <input type="button" id="ssrecording" value="ðŸ”´ Record"><!--ðŸŸ¥ Stop recording-->
        <select id="target">
          <option value="canvas" selected>Canvas</option>
          <option value="screen">Screen</option>
          <option value="camera">Camera</option>
        </select><br>
      </td>
    </tr>
  </table>
  <p id="capturedVideo">Captured video:<br>
    <video id="preview" playsinline autoplay muted controls></video>
  </p>
  <p id="capturedImg" style="display: none;">Captured PNG image:<br>
    <img id="png" style="background: lightgray; padding: 10px;"></img>
  </p>
  <a id="recordedFile" style="display: none;"></a>

  <script>
    let context, x,y,dx,dy, W=50,H=30, colors=[];
    let utms, tms=0, ts=0, animating;
    let stream, recorder, vidchunks=[];
    function recorderStopped(e){
      target.disabled = false;
      let blob = new Blob(vidchunks, {'type': 'video/webm'});
      vidchunks = [];
      let videoURL = URL.createObjectURL(blob);
      recordedFile.href = videoURL;
      recordedFile.download = 'screen-capture-record.webm';
      recordedFile.click();
      console.log('Recorded video: '+videoURL);
      URL.revokeObjectURL(videoURL); // Don't litter the memory!
    }
    async function setupRecorder(){
      if(target.value=='canvas'){
        stream = canvas.captureStream(30);
        capturedImg.style.display = 'block';
      }else{ capturedImg.style.display = 'none';}
      if(target.value=='screen'){
        try{ stream = await navigator.mediaDevices.getDisplayMedia({audio: true, video: true});
        } catch (e) { alert('getDisplayMedia():'+e); return; }
      }
      if(target.value=='camera'){
        try{ stream = await navigator.mediaDevices.getUserMedia({audio: true, video: true});
        } catch (e) { alert('getUserMedia(): '+e); return; }
      }
      preview.srcObject = stream;
      console.log(stream.getVideoTracks()[0]);
      const options = { mimeType: 'video/webm;codecs=vp9' };
      // or fallback to vp8 if vp9 not supported
      if (!MediaRecorder.isTypeSupported(options.mimeType)) {
        options.mimeType = 'video/webm;codecs=vp8';
      }
      recorder = new MediaRecorder(stream, options);
      console.log("Using recorder mimeType:", recorder.mimeType);
      recorder.ondataavailable = function(e){ vidchunks.push(e.data); };
      recorder.onstart = function(e){ target.disabled = true; }
      recorder.onstop = recorderStopped;
    }
    async function init() { // Set up everything
      utms = Date.now(); animating = true;
      context = canvas.getContext("2d");
      x = y = 10; dx = dy = 1;
      colors = ['red','green','blue','yellow','cyan','magenta'];
      setupRecorder();
    }
    ssanimation.onclick = function (e) {
      if (animating) { //stop now
        ssanimation.value = 'â–¶ï¸ Start';
        animating = false;
      } else { //start now
        ssanimation.value = 'â¹ï¸ Stop';
        animating = true; utms = Date.now(); animate();
      }
    }
    target.onchange = function(e){ setupRecorder(); }
    function startRecording(){
      if(recorder.state == 'recording'){ return }
      recorder.start();
      ssrecording.value = 'ðŸŸ¥ Stop recording';
    }
    function stopRecording(){
      if(recorder.state == 'inactive'){ return }
      recorder.stop();
      ssrecording.value = 'ðŸ”´ Record';
    }
    ssrecording.onclick = function (e) {
      if(recorder.state == 'recording'){ stopRecording(); }else{ startRecording(); }
    }
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    async function animate() {
      if(!animating){ return }
      if(false){ await sleep(100); }
      let dt = Date.now() - utms; tms += dt; utms = Date.now();
      if((tms > 1000)){
        //console.log('t:'+ts+'s +'+dt+'('+((tms-1000)/1000.0)+')');
        ts++; tms = 0;
      }
      x += dx*dt/10.0;
      if(x+W > canvas.width-10){ dx = -1; }
      if(x < 10){ dx = +1; }
      y += dy*dt/10.0;
      if(y+H > canvas.height-10){ dy = -1; }
      if(y < 10){ dy = +1; }
      context.fillStyle = colors[ts%colors.length]
      context.fillRect(x, y, W, H);
      png.src = canvas.toDataURL('image/png'); // captured as an png
      requestAnimationFrame(animate);
    }
    init();
    animate();

</script>
</body>

</html>